# vim: ft=make ts=4 sw=4 ff=unix noet
# do not use CC for executables (see rule %: %.meta_info.m)
.SUFFIXES:

SEMVER_RE := ([0-9]+)[.]([0-9]+)[.]([0-9]+)([-][0-9a-zA-Z_]+)?([+][0-9a-zA-Z_]+)?
PKG_TUPLE_VER_RE := "s/^version[(]\"$(SEMVER_RE)\"[)].+/ \
-e s\/<version>\/{\1,\2,\3,\"\4\",\"\5\"}\/i/p"
PKG_DIST_VER_RE  := "s/^version[(]\"$(SEMVER_RE)\"[)].+/\1.\2.\3\4/p"
PKG_LIBNAME_DEPS_RE := "s/^dep[(]\"lib([^\"]+)[\"].+/\1/p"
PKG_LIBVER_DEPS_RE  := "s/^dep[(]\"(lib[^\"]+)[\"]\s*-\s*\"([^\"]+)\".+/\1\/\2/p"

PKG_MULTI    := contrib
PKG_MULTI_RE := "s/^($(PKG_MULTI))[(]([^)]+)[)].+/-e s\/<\1s>\/\2\|[<\1s>]\/i/p"

PKG_DEPS_RE := "s/^(dep)[(]\"lib([^)]+)[)].+/-e s\/<\1s>\/\"\2\|<NL>[<\1s>]\/i/p"

PKG_VARS    := src_dir
PKG_VARS_RE := "s/($(PKG_VARS))[(]\"([^\"]+)[\"][)].+/-e s\/<\1>\/\2\/i/p"

AUTHOR_NAME  := $(GIT_AUTHOR_NAME)
ifndef AUTHOR_NAME
    AUTHOR_NAME := $(shell $(GIT) config --get user.name)
endif

AUTHOR_EMAIL := $(GIT_AUTHOR_EMAIL)
ifndef AUTHOR_EMAIL
    AUTHOR_EMAIL := $(shell $(GIT) config --get user.email)
endif

GIT_REVISION_SHORT := $(shell $(GIT) rev-parse --short HEAD 2>/dev/null)
GIT_REVISION_LONG  := $(shell $(GIT) describe --tags 2>/dev/null || \
	$(GIT) rev-parse HEAD)
REVISION_SHORT := $(GIT_REVISION_SHORT)
REVISION_LONG  := $(GIT_REVISION_LONG)
TIMESTAMP      := $(shell $(DATE))

# Build the local version of the library if provided by this package.
# This is ensured by the meta_info.m rules, which depends on lib%.package
lib%: $(PKG_ROOT)/lib%.package %.meta_info.m Mercury.modules
	@$(eval lib$*_INSTALL_DIR := \
		$(INSTALL_PREFIX)/lib$*/$(shell $(SED) -n -e $(PKG_DIST_VER_RE) $<))
	@echo MMC --install-prefix="$(lib$*_INSTALL_DIR)" --make lib$*.install
	@$(MMC) --install-prefix="$(lib$*_INSTALL_DIR)" --make lib$*.install

Mercury.modules: $(wildcard *.m)
	@echo "MMC -f $^"
	@$(MMC) -f $^

# generating meta_info.m for package information available at compile time
.PRECIOUS: %.meta_info.m
META_INFO_TMPL_COMMON_REPLACE = $(SED)               \
    `$(SED) -n -e $(PKG_TUPLE_VER_RE) $<`            \
    `$(SED) -n -e $(PKG_MULTI_RE)     $<`            \
    `$(SED) -n -e $(PKG_DEPS_RE)      $<`            \
    -e "s/<MODULE>/$*/g"                             \
    -e "s/<AUTHOR_NAME>/$(AUTHOR_NAME)/"             \
    -e "s/<AUTHOR_EMAIL>/$(AUTHOR_EMAIL)/"           \
    -e "s/<REVISION_SHORT>/$(REVISION_SHORT)/"       \
    -e "s/<REVISION_LONG>/$(REVISION_LONG)/"         \
    -e "s/<TIMESTAMP>/$(TIMESTAMP)/"                 \
    -e "s/<SRC_DIR>/src/"                            \
    -e "s/<($(PKG_MULTI))s>//i"                      \
    -e "s/<DEPS>//i"                                 \
    -e "s/<NL>/\n    /i"                             \
        < $(META_INFO_TMPL) >$@
#  -e "s/<IMPORTS>/$(foreach )/g"

%.meta_info.m :: $(PKG_ROOT)/lib%.package $(META_INFO_TMPL)
	@echo GEN $*.meta_info.m \(library\)
	$(shell $(META_INFO_TMPL_COMMON_REPLACE))

%.meta_info.m :: $(PKG_ROOT)/%.package $(META_INFO_TMPL)
	@echo GEN $*.meta_info.m \(executable\)
	$(shell $(META_INFO_TMPL_COMMON_REPLACE))

%.dep_vars: $(PKG_ROOT)/%.package %.meta_info.m
	@$(eval $*_LIBNAME_DEPS := \
		$(shell $(SED) -n -e $(PKG_LIBNAME_DEPS_RE) $<))
	@$(eval $*_LIBVER_DEPS := \
		$(shell $(SED) -n -e $(PKG_LIBVER_DEPS_RE) $<))

# XXX: This rule comes last since it might be a (unwanted) catch-call rule
# XXX: The dependency analysis used in this rule is temporary, and
# SHOULD be done by mpm, e.g. exe%: $(%_DEPS) %$(EXE_EXT)
%$(EXE_EXT): %.dep_vars Mercury.modules
	@echo MMC --make $*
	$(MMC) --make $* \
		$(foreach DEP,$($*_LIBVER_DEPS),--mld $(INSTALL_PREFIX)/$(DEP)/lib/mercury) \
		$(foreach LIB,$($*_LIBNAME_DEPS),--ml $(LIB))
